package org.example;

import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.List;

public class Day_2024_15 {

    private static Position[][] grid;
    private static Position[][] wideGrid;
    private static List<Position> positionList;

    public static void main(String[] args) throws FileNotFoundException {
        List<String> lines = Tools.getLines("2024_15");
        lines = Tools.getLines("2024_15_test_01");
//    lines = Tools.getLines("2024_15_test_02");
        lines = Tools.getLines("2024_15_test_04");

        int instructionCounter = 0;

        int maxY = 0;
        int maxX = 0;

        long sum = 0;

        Position startPosition = null;

        for (String line : lines) {
            if (line.isBlank())
                break;
            maxY++;
            maxX = line.length();
        }

        for (int y = maxY + 1; y < lines.size(); y++) {
            for (int x = 0; x < lines.get(y).length(); x++) {
                instructionCounter++;
            }
        }
        char[] instructions = new char[instructionCounter];

        int counter = 0;
        for (int y = maxY + 1; y < lines.size(); y++) {
            for (int x = 0; x < lines.get(y).length(); x++) {
                instructions[counter++] = lines.get(y).charAt(x);
            }
        }


        List<String> wideLines = new ArrayList<>();
        for (String line : lines) {
            String wideLine = "";
            for (int i = 0; i < line.length(); i++) {
                if (line.charAt(i) == '#')
                    wideLine += "##";
                else if (line.charAt(i) == 'O') {
                    wideLine += "[]";
                } else if (line.charAt(i) == '.') {
                    wideLine += "..";
                } else if (line.charAt(i) == '@') {
                    wideLine += "@.";
                }
            }
            wideLines.add(wideLine);
        }


        positionList = new ArrayList<>();
        wideGrid = new Position[maxY][maxX * 2];

        for (int y = 0; y < wideLines.size(); y++) {
            String wideLine = wideLines.get(y);
            for (int x = 0; x < wideLine.length(); x++) {
                wideGrid[y][x] = new Position(y, x, wideLine.charAt(x));
                if (wideLine.charAt(x) == '@') {
                    startPosition = wideGrid[y][x];
                }
//                if (wideLine.charAt(x) == '@') {
//                    startPosition = new Position(y, x, wideLine.charAt(x));
//                    positionList.add(startPosition);
//                } else {
//                    positionList.add(new Position(y, x, wideLine.charAt(x)));
//                }
            }
        }

//        for (int theY = 0; theY < maxY; theY++) {
//            for (int theX = 0; theX < maxX * 2; theX++) {
//                int finalTheY = theY;
//                int finalTheX = theX;
//                System.out.printf(String.valueOf(positionList.stream().filter(p -> p.y == finalTheY && p.x == finalTheX).findFirst().get().c));
//            }
//            System.out.println();
//        }
//        System.out.println();


        int y = startPosition.y;
        int x = startPosition.x;

        printGrid(wideGrid);


        for (char instruction : instructions) {
            switch (instruction) {
                case '^' -> {
                    if (y > 1 && wideGrid[y - 1][x].c == '.') {
                        wideGrid[y][x] = new Position(y, x, '.');
                        startPosition.y--;
                        y--;
                        wideGrid[y][x] = startPosition;
                    } else if (y > 1 && (wideGrid[y - 1][x].c == ']' || wideGrid[y - 1][x].c == '[')) {
                        // todo


                        List<String> packagesToMoveList = new ArrayList<>();
                        int shiftYCounter = 0;
                        int rangeX = 0;
                        
                        // todo setze den ersten Block, den man verschiebt und daran die ranges
                        int rangeXNegative = 0;
                        int rangeXPositive = 0;

                       if(wideGrid[y - 1][x].c == ']') {
                           rangeXPositive = x;
                           rangeXNegative = x-1;
                       }
                       if(wideGrid[y - 1][x].c == '[') {
                           rangeXPositive = x + 1;
                           rangeXNegative = x;
                       }
                        // die erhöht sich mit jedem shiftYCounter... aber vllt. -1 am Ende
                        
                        while(wideGrid[y-1-shiftYCounter][x].c != '.' || wideGrid[y-1-shiftYCounter][x-1].c != '.' || wideGrid[y-1-shiftYCounter][x+1].c != '.')
                        {
                            // to right
                            int myXPositive = x;
                            // todo: die while-Schleife unterhalb durch for-Schleife mit ranges ersetzen
                            // todo: nur Kisten einsammeln!
                            // todo: man muss vor dem Verschieben bei jeder Position sicherstellen, dass y-1 kein # ist
                            // todo: ANSONSTEN DARF MAN NICHT VERSCHIEBEN!!!
                            while (wideGrid[y-1][myXPositive].c != '.') {
                                // nicht dann aufhören, weil es auch einen Block dazwischen geben darf:
                                // 
                                //   [][][][]     [][][][]
                                //    []##[]      []  <>[]  die beiden <> werden nicht mitgeschoben
                                //    []  []      []  <>[]
                                //    [][][]       []   []
                                //     [][]         [][][]
                                //      []           [][]
                                //                    []
                                // man muss alles einsammeln und vor dem Verschieben jede Position prüfen, ob y-1 kein # ist
//                                if (wideGrid[y-1][myXPositive].c == '#')
//                                    break;
                                if(wideGrid[y-shiftYCounter][myXPositive].c == '[' || wideGrid[y-shiftYCounter][myXPositive].c == ']' )
                                    packagesToMoveList.add(y-1-shiftYCounter + "-" + myXPositive);
                                myXPositive++;
                            }
                            // to left
                            int myXNegative = x;
                            while (wideGrid[y-1][myXNegative].c != '.') {
                                if (wideGrid[y-1][myXNegative].c == '#')
                                    break;
                                if(wideGrid[y-shiftYCounter][myXNegative].c == '[' || wideGrid[y-shiftYCounter][myXNegative].c == ']' )
                                    packagesToMoveList.add(y-1-shiftYCounter + "-" + myXNegative);
                                myXNegative--;
                            }
                            shiftYCounter++;
                            rangeXPositive++;
                            rangeXNegative++;
                        }


                        int packagesToMove = 0;
                        int myY = y;
                        while (y > 2 && wideGrid[myY - 1][x].c != '.') {
                            if (wideGrid[myY - 1][x].c == '#') {
                                packagesToMove = 0;
                                break;
                            }
                            packagesToMove++;
                            myY--;
                        }
                        if (packagesToMove > 0) {
                            for (int i = y - 1 - packagesToMove; i <= y - 1; i++) {
                                wideGrid[i][x] = new Position(y, x, 'O');
                                if (i == y - 1)
                                    wideGrid[i][x] = startPosition;

                            }
                            wideGrid[y][x] = new Position(y, x, '.');
                            startPosition.y--;
                            y--;
                        }
                    }

                }
                case '>' -> {
                    if (x < wideGrid[0].length - 2 && wideGrid[y][x + 1].c == '.') {
                        wideGrid[y][x] = new Position(y, x, '.');
                        startPosition.x++;
                        x++;
                        wideGrid[y][x] = startPosition;
                    } else if (x < wideGrid[0].length - 2 && wideGrid[y][x + 1].c == 'O') {
                        // todo
                        int packagesToMove = 0;
                        int myX = x;
                        while (x < wideGrid[0].length - 2 && wideGrid[y][myX + 1].c != '.') {
                            if (wideGrid[y][myX + 1].c == '#') {
                                packagesToMove = 0;
                                break;
                            }
                            packagesToMove++;
                            myX++;
                        }
                        if (packagesToMove > 0) {
                            for (int i = x + 1 + packagesToMove; i >= x + 1; i--) {
                                wideGrid[y][i] = new Position(y, x, 'O');
                                if (i == x + 1)
                                    wideGrid[y][i] = startPosition;

                            }
                            wideGrid[y][x] = new Position(y, x, '.');
                            startPosition.x++;
                            x++;
                        }
                    }

                }
                case 'v' -> {
                    if (y < wideGrid.length - 2 && wideGrid[y + 1][x].c == '.') {
                        wideGrid[y][x] = new Position(y, x, '.');
                        startPosition.y++;
                        y++;
                        wideGrid[y][x] = startPosition;

                        // UNTEN

                    } else if (y < wideGrid.length - 2 && wideGrid[y + 1][x].c == 'O') {
                        // todo
                        int packagesToMove = 0;
                        int myY = y;
                        while (y < wideGrid[0].length - 2 && wideGrid[myY + 1][x].c != '.') {
                            if (wideGrid[myY + 1][x].c == '#') {
                                packagesToMove = 0;
                                break;
                            }
                            packagesToMove++;
                            myY++;
                        }
                        if (packagesToMove > 0) {
                            for (int i = y + 1 + packagesToMove; i >= y + 1; i--) {
                                wideGrid[i][x] = new Position(y, x, 'O');
                                if (i == y + 1)
                                    wideGrid[i][x] = startPosition;

                            }
                            wideGrid[y][x] = new Position(y, x, '.');
                            startPosition.y++;
                            y++;
                        }
                    }


                }
                case '<' -> {
                    if (x > 1 && wideGrid[y][x - 1].c == '.') {
                        wideGrid[y][x] = new Position(y, x, '.');
                        startPosition.x--;
                        x--;
                        wideGrid[y][x] = startPosition;
                    } else if (x > 1 && wideGrid[y][x - 1].c == ']') {
                        // todo
                        int packagesToMove = 0;
                        int myX = x;
                        while (x > 2 && wideGrid[y][myX - 1].c != '.') {
                            if (wideGrid[y][myX - 1].c == '#') {
                                packagesToMove = 0;
                                break;
                            }
                            packagesToMove++;
                            myX--;
                        }
                        if (packagesToMove > 0) {
                            int packageMovCounter = 0;
                            for (int i = x - 1 - packagesToMove; i <= x - 1; i++) {
                                wideGrid[y][i] = new Position(y, x, packageMovCounter % 2 == 0 ? '[' : ']');
                                if (i == x - 1)
                                    wideGrid[y][i] = startPosition;
                                packageMovCounter++;
                            }
                            wideGrid[y][x] = new Position(y, x, '.');
                            startPosition.x--;
                            x--;
                        }
                    }

                }
            }
            printGrid(wideGrid);
            System.out.println();
        }


//        solvePartOne(maxY, maxX, lines, startPosition, instructions, sum);
    }

    private static Position getGridPos(final int y, final int x) {
        return positionList.stream().filter(p -> p.y == y && p.x == x).findFirst().get();
    }

    private static void solvePartOne(int maxY, int maxX, List<String> lines, Position startPosition, char[] instructions, long sum) {
        grid = new Position[maxY][maxX];
        for (int y = 0; y < maxY; y++) {
            String line = lines.get(y);
            for (int x = 0; x < line.length(); x++) {
                grid[y][x] = new Position(y, x, line.charAt(x));
                if (line.charAt(x) == '@') {
                    startPosition = grid[y][x];
                }
            }
        }

        int y = startPosition.y;
        int x = startPosition.x;

        printGrid();


        for (char instruction : instructions) {
            switch (instruction) {
                case '^' -> {
                    if (y > 1 && grid[y - 1][x].c == '.') {
                        grid[y][x] = new Position(y, x, '.');
                        startPosition.y--;
                        y--;
                        grid[y][x] = startPosition;
                    } else if (y > 1 && grid[y - 1][x].c == 'O') {
                        // todo
                        int packagesToMove = 0;
                        int myY = y;
                        while (y > 2 && grid[myY - 1][x].c != '.') {
                            if (grid[myY - 1][x].c == '#') {
                                packagesToMove = 0;
                                break;
                            }
                            packagesToMove++;
                            myY--;
                        }
                        if (packagesToMove > 0) {
                            for (int i = y - 1 - packagesToMove; i <= y - 1; i++) {
                                grid[i][x] = new Position(y, x, 'O');
                                if (i == y - 1)
                                    grid[i][x] = startPosition;

                            }
                            grid[y][x] = new Position(y, x, '.');
                            startPosition.y--;
                            y--;
                        }
                    }

                }
                case '>' -> {
                    if (x < grid[0].length - 2 && grid[y][x + 1].c == '.') {
                        grid[y][x] = new Position(y, x, '.');
                        startPosition.x++;
                        x++;
                        grid[y][x] = startPosition;
                    } else if (x < grid[0].length - 2 && grid[y][x + 1].c == 'O') {
                        // todo
                        int packagesToMove = 0;
                        int myX = x;
                        while (x < grid[0].length - 2 && grid[y][myX + 1].c != '.') {
                            if (grid[y][myX + 1].c == '#') {
                                packagesToMove = 0;
                                break;
                            }
                            packagesToMove++;
                            myX++;
                        }
                        if (packagesToMove > 0) {
                            for (int i = x + 1 + packagesToMove; i >= x + 1; i--) {
                                grid[y][i] = new Position(y, x, 'O');
                                if (i == x + 1)
                                    grid[y][i] = startPosition;

                            }
                            grid[y][x] = new Position(y, x, '.');
                            startPosition.x++;
                            x++;
                        }
                    }

                }
                case 'v' -> {
                    if (y < grid.length - 2 && grid[y + 1][x].c == '.') {
                        grid[y][x] = new Position(y, x, '.');
                        startPosition.y++;
                        y++;
                        grid[y][x] = startPosition;

                        // UNTEN

                    } else if (y < grid.length - 2 && grid[y + 1][x].c == 'O') {
                        // todo
                        int packagesToMove = 0;
                        int myY = y;
                        while (y < grid[0].length - 2 && grid[myY + 1][x].c != '.') {
                            if (grid[myY + 1][x].c == '#') {
                                packagesToMove = 0;
                                break;
                            }
                            packagesToMove++;
                            myY++;
                        }
                        if (packagesToMove > 0) {
                            for (int i = y + 1 + packagesToMove; i >= y + 1; i--) {
                                grid[i][x] = new Position(y, x, 'O');
                                if (i == y + 1)
                                    grid[i][x] = startPosition;

                            }
                            grid[y][x] = new Position(y, x, '.');
                            startPosition.y++;
                            y++;
                        }
                    }


                }
                case '<' -> {
                    if (x > 1 && grid[y][x - 1].c == '.') {
                        grid[y][x] = new Position(y, x, '.');
                        startPosition.x--;
                        x--;
                        grid[y][x] = startPosition;
                    } else if (x > 1 && grid[y][x - 1].c == 'O') {
                        // todo
                        int packagesToMove = 0;
                        int myX = x;
                        while (x > 2 && grid[y][myX - 1].c != '.') {
                            if (grid[y][myX - 1].c == '#') {
                                packagesToMove = 0;
                                break;
                            }
                            packagesToMove++;
                            myX--;
                        }
                        if (packagesToMove > 0) {
                            for (int i = x - 1 - packagesToMove; i <= x - 1; i++) {
                                grid[y][i] = new Position(y, x, 'O');
                                if (i == x - 1)
                                    grid[y][i] = startPosition;

                            }
                            grid[y][x] = new Position(y, x, '.');
                            startPosition.x--;
                            x--;
                        }
                    }

                }
            }
//      System.out.println(instruction);
//      printGrid();
//      System.out.println();


        }

        for (int y1 = 0; y1 < grid.length; y1++) {
            for (int x1 = 0; x1 < grid[0].length; x1++) {
                if (grid[y1][x1].c == 'O') {
                    sum += y1 * 100L + x1;
                }
            }
        }
//    printGrid();

        System.out.println(sum);
    }

    private static void printGrid(Position[][] grid1) {
        for (int y = 0; y < grid1.length; y++) {
            for (int x = 0; x < grid1[0].length; x++) {
                System.out.print(grid1[y][x].c);
            }
            System.out.println();
        }
        System.out.println();
    }

    private static void printGrid() {
        for (int y = 0; y < grid.length; y++) {
            for (int x = 0; x < grid[0].length; x++) {
                System.out.print(grid[y][x].c);
            }
            System.out.println();
        }
        System.out.println();
    }

    private static class Position {
        int y;
        int x;
        char c;

        public Position(int y, int x, char c) {
            this.y = y;
            this.x = x;
            this.c = c;
        }
    }
}
